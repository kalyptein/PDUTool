/* This code was generated by Quality Research, Inc for the Aviation and
Missile Command (AMCOM). */

package utilities;

import geotransform.coords.*;
import geotransform.ellipsoids.*;
import geotransform.transforms.*;

/**
 * The UTMToGccConverter class provides optimized versions of the GeoTransform
 * Library's Utm_To_Gcc_Converter methods.  This class provides functionality
 * to convert location, velocity and orientation vectors from UTM to Geocentric
 * coordinates.
 * 
 * @author Chris Burns / Margaretha T. Little
 * @version 1.0
 */
public class UTMToGccConverter extends Utm_To_Gcc_Converter
{
    protected static Utm_Coord_3d[] utm_coord_3ds = new Utm_Coord_3d[1];
    protected static Gcc_Coord_3d[] gcc_coord_3ds = new Gcc_Coord_3d[1];
    protected static Gdc_Coord_3d[] gdc_coord_3ds = new Gdc_Coord_3d[utm_coord_3ds.length];

    protected static double[][] xformMatrix = new double[3][3];

    public static void Init(double d, double d_0_)
    {
        A = d;
        F = d_0_;
    }

    public static void Init()
    {
        A = 6378137.0;
        F = 298.257223563;
    }

    public static void Init(Ellipsoid ellipsoid)
    {
        e = ellipsoid;
        A = e.a;
        F = e.f;
    }

    public static void Convert(Utm_Coord_3d utm_coord_3d,
        Gcc_Coord_3d gcc_coord_3d)
        {
            utm_coord_3ds[0] = utm_coord_3d;
            gcc_coord_3ds[0] = gcc_coord_3d;
            Convert(utm_coord_3ds, gcc_coord_3ds);
    }

    public static void Convert(Utm_Coord_3d[] utm_coord3ds, Gcc_Coord_3d[] gcc_coord3ds)
    {
    	for(int i = 0; i < utm_coord3ds.length; i++)
    		gdc_coord_3ds[i] = new Gdc_Coord_3d();
    	
    	Utm_To_Gdc_Converter.Init(A, F);
    	Utm_To_Gdc_Converter.Convert(utm_coord3ds, gdc_coord_3ds);
    	Gdc_To_Gcc_Converter.Init(A, F);
    	Gdc_To_Gcc_Converter.Convert(gdc_coord_3ds, gcc_coord3ds);
    }

    public static void ComputeXForm(double Ex, double Ey, double Ez)
    {
        xformMatrix[0][0] = Math.cos(Ez)*Math.cos(Ey);
        xformMatrix[0][1] = Math.sin(Ez)*Math.cos(Ey);
        xformMatrix[0][2] = -(Math.sin(Ey));
        xformMatrix[1][0] = (Math.cos(Ez)*Math.sin(Ey)*Math.sin(Ex)) -
                            (Math.sin(Ez)*Math.cos(Ex));
        xformMatrix[1][1] = (Math.sin(Ez)*Math.sin(Ey)*Math.sin(Ex)) +
                            (Math.cos(Ez)*Math.cos(Ex));
        xformMatrix[1][2] = Math.cos(Ey)*Math.sin(Ex);
        xformMatrix[2][0] = (Math.cos(Ez)*Math.sin(Ey)*Math.cos(Ex)) +
                            (Math.sin(Ez)*Math.sin(Ex));
        xformMatrix[2][1] = (Math.sin(Ez)*Math.sin(Ey)*Math.cos(Ex)) -
                            (Math.cos(Ez)*Math.sin(Ex));
        xformMatrix[2][2] = Math.cos(Ey)*Math.cos(Ex);
    }

    /**
     * Calculates either the Geocentric Theta (Pitch) angle -or- Theta angular rate, depending
     * on what inputs are provided to the method.  The inputs are in UTM coordinates, but
     * are converted into Geocentric coordinates prior to returning the values.  This
     * conversion routine is necessary because values in the IDEEAS application are in
     * UTM coordinates, but the values in the DIS PDUs must be in Geocentric coordinates.
     *
     * @param lat - the Geodetic latitude of the Platform's current position (in radians)
     * @param utmTheta - the UTM Theta (Pitch) angle (radians) -or- the Theta angular rate (radians/second)
     * @param utmPsi - the UTM Psi (Heading/Yaw) angle (radians) -or- the Psi angular rate (radians/second)
     *
     * @return the Geocentric Theta (Pitch) angle (radians) -or- the Theta angular rate (radians/second)
     */
    public static double computeTheta(double lat, double utmTheta, double utmPsi)
    {
        double theta;

        theta = Math.asin(-Math.cos(lat)*Math.cos(utmPsi)*Math.cos(utmTheta)
                          -Math.sin(lat)*Math.sin(utmTheta));
        return theta;
    }

    /**
     * Calculates either the Geocentric Psi (Heading/Yaw) angle -or- the Psi angular rate,
     * depending on what inputs are provided to the method.  The inputs are in UTM coordinates, but
     * are converted into Geocentric coordinates prior to returning the values.  This
     * conversion routine is necessary because values in the IDEEAS application are in
     * UTM coordinates, but the values in the DIS PDUs must be in Geocentric coordinates.
     *
     * @param lat - the Geodetic latitude of the Platform's current position (in radians)
     * @param lon - the Geodetic longitude of the Platform's current position (in radians)
     * @param utmPsi - the UTM Psi (Heading/Yaw) angle (radians) -or- the Psi angular rate (radians/second)
     * @param utmTheta - the UTM Theta (Pitch) angle (radians) -or- the Theta angular rate (radians/second)
     *
     * @return the Geocentric Psi (Heading/Yaw) angle (radians) -or- the Psi angular rate (radians/second)
     */
    public static double computePsi(double lat, double lon, double utmPsi, double utmTheta)
    {
        double A11, A12, psi;

        psi = 0.0;

        A11 = -Math.sin(lon)*Math.sin(utmPsi)*Math.cos(utmTheta)
              -Math.sin(lat)*Math.cos(lon)*Math.cos(utmPsi)*Math.cos(utmTheta)
              + Math.cos(lat)*Math.cos(lon)*Math.sin(utmTheta);

        A12 = Math.cos(lon)*Math.sin(utmPsi)*Math.cos(utmTheta)
              -Math.sin(lat)*Math.sin(lon)*Math.cos(utmPsi)*Math.cos(utmTheta)
              + Math.cos(lat)*Math.sin(lon)*Math.sin(utmTheta);

        try
        {
            psi = Math.atan(Math.abs(A12)/Math.abs(A11));
        }
		catch(Exception ex)
        {
            if (A12 > 0)
            {
                psi = Math.PI/2;
            }
            else
            {
                psi = 3*Math.PI/2;
            }
        }

        /**
         * Check to see which quadrant the vector is in. If both the numerator and denomenator are positive,
         * the vector is in Quadrant 1. If the denominator is negative, the vector must be in Quadrant 2 or
         * 3.  If the numerator is negative, the vector must be in Quadrant 3 or 4.  Therefore,
         * +A11,+A12 = Q1; -A11,+A12 = Q2; -A11,-A12 = Q3; and +A11,-A12 = Q4.
		 */
        if(A11 > 0)
        {
            if(A12 > 0)
            {
		        psi = Math.atan(A12/A11);  // psi is correct, do not adjust the angle
            }
            else if(A12 < 0)
            {
		        psi = Math.atan(A12/A11);  // psi is in quadrant 4, adjust the angle
                psi = (2*Math.PI) + psi;
            }
            else if(A12 == 0)
            {
                psi = 0;
            }
        }
        else if(A11 < 0)
        {
            if(A12 > 0)
            {
		        psi = Math.atan(A12/A11);  // psi is in quadrant 2, adjust the angle
                psi = Math.PI + psi;
            }
            else if(A12 < 0)
            {
		        psi = Math.atan(A12/A11);  // psi is in quadrant 3, adjust the angle
                psi = Math.PI + psi;
            }
            else if(A12 == 0)
            {
                psi = Math.PI;
            }
        }
        else
        {
            if(A12 > 0)
                psi = Math.PI / 2;
            else if(A12 < 0)
                psi = -Math.PI / 2;
        }

        return psi;
    }

    /**
     * Calculates either the Geocentric Phi (Roll) angle -or- the Phi angular rate,
     * depending on what inputs are provided to the method.  The inputs are in UTM coordinates, but
     * are converted into Geocentric coordinates prior to returning the values.  This
     * conversion routine is necessary because values in the IDEEAS application are in
     * UTM coordinates, but the values in the DIS PDUs must be in Geocentric coordinates.
     *
     * @param lat - the Geodetic latitude of the Platform's current position (in radians)
     * @param utmTheta - the UTM Theta (Pitch) angle (radians) -or- the Theta angular rate (radians/second)
     * @param utmPhi - the UTM Phi (Roll) angle (radians) -or- the Phi angular rate (radians/second)
     * @param utmPsi - the UTM Psi (Heading/Yaw) angle (radians) -or- the Psi angular rate (radians/second)
     *
     * @return the Geocentric Phi (Roll) angle (radians) -or- the Phi angular rate (radians/second)
     */
    public static double computePhi(double lat, double utmTheta, double utmPhi, double utmPsi)
    {
        double A23, A33, phi;

        phi = 0.0;

        A23 = Math.cos(lat)
              * (-Math.sin(utmPsi)*Math.cos(utmPhi) + Math.cos(utmPsi)*Math.sin(utmTheta)*Math.sin(utmPhi))
              -Math.sin(lat)*Math.cos(utmTheta)*Math.sin(utmPhi);

        A33 = Math.cos(lat)
              * (Math.sin(utmPsi)*Math.sin(utmPhi) + Math.cos(utmPsi)*Math.sin(utmTheta)*Math.cos(utmPhi))
              -Math.sin(lat)*Math.cos(utmTheta)*Math.cos(utmPhi);

        /**
         * Check to see which quadrant the vector is in. If both the numerator and denomenator are positive,
         * the vector is in Quadrant 1. If the denominator is negative, the vector must be in Quadrant 2 or
         * 3.  If the numerator is negative, the vector must be in Quadrant 3 or 4.  Therefore,
         * +A33,+A23 = Q1; -A33,+A23 = Q2; -A33,-A23 = Q3; and +A33,-A23 = Q4.
		 */
        if(A33 > 0)
        {
            if(A23 > 0)
            {
		        phi = Math.atan(A23/A33);  // phi is correct, do not adjust the angle
            }
            else if(A23 < 0)
            {
		        phi = Math.atan(A23/A33);  // phi is in quadrant 4, adjust the angle
                phi = (2*Math.PI) + phi;
            }
            else if(A23 == 0)
            {
                phi = 0;
            }
        }
        else if(A33 < 0)
        {
            if(A23 > 0)
            {
		        phi = Math.atan(A23/A33);  // phi is in quadrant 2, adjust the angle
                phi = Math.PI + phi;
            }
            else if(A23 < 0)
            {
		        phi = Math.atan(A23/A33);  // phi is in quadrant 3, adjust the angle
                phi = Math.PI + phi;
            }
            else if(A23 == 0)
            {
                phi = Math.PI;
            }
        }
        else
        {
            if(A23 > 0)
                phi = Math.PI / 2;
             else if(A23 < 0)
                phi = -Math.PI / 2;
        }

        return phi;
    }

    public static double[][] getXFormMatrix()
    {
        return xformMatrix;
    }

    /**
     * Calculates the X component of the Velocity vector for the Platform.  The X component
     * is the UTM component converted into Geocentric coordinates.
     *
     * @param lat - the Geodetic latitude of the Platform's current position (in radians)
     * @param lon - the Geodetic longitude of the Platform's current position (in radians)
     * @param utmVelX - the X component of the Velocity vector (in UTM coordinates)
     * @param utmVelY - the Y component of the Velocity vector (in UTM coordinates)
     * @param utmVelZ - the Z component of the Velocity vector (in UTM coordinates)
     *
     * @return the X component of the Velocity vector (in Geocentric coordinates)
     */
    public static double computeVelocityX(double lat, double lon, double utmVelX, double utmVelY, double utmVelZ)
    {
        double velX;

        velX = -Math.sin(lon)*utmVelX
               -Math.sin(lat)*Math.cos(lon)*utmVelY
               +Math.cos(lat)*Math.cos(lon)*utmVelZ;

        return velX;
    }

    /**
     * Calculates the Y component of the Velocity vector for the Platform.  The Y component
     * is the UTM component converted into Geocentric coordinates.
     *
     * @param lat - the Geodetic latitude of the Platform's current position (in radians)
     * @param lon - the Geodetic longitude of the Platform's current position (in radians)
     * @param utmVelX - the X component of the Velocity vector (in UTM coordinates)
     * @param utmVelY - the Y component of the Velocity vector (in UTM coordinates)
     * @param utmVelZ - the Z component of the Velocity vector (in UTM coordinates)
     *
     * @return the Y component of the Velocity vector (in Geocentric coordinates)
     */
    public static double computeVelocityY(double lat, double lon, double utmVelX, double utmVelY, double utmVelZ)
    {
        double velY;

        velY = Math.cos(lon)*utmVelX
               -Math.sin(lat)*Math.sin(lon)*utmVelY
               +Math.cos(lat)*Math.sin(lon)*utmVelZ;

        return velY;
    }

    /**
     * Calculates the Z component of the Velocity vector for the Platform.  The Z component
     * is the UTM component converted into Geocentric coordinates.
     *
     * @param lat - the Geodetic latitude of the Platform's current position (in radians)
     * @param utmVelY - the Y component of the Velocity vector (in UTM coordinates)
     * @param utmVelZ - the Z component of the Velocity vector (in UTM coordinates)
     *
     * @return the Z component of the Velocity vector (in Geocentric coordinates)
     */
    public static double computeVelocityZ(double lat, double utmVelY, double utmVelZ)
    {
        double velZ;

        velZ = Math.cos(lat)*utmVelY + Math.sin(lat)*utmVelZ;

        return velZ;
    }

}

/* This code was generated by Quality Research, Inc for the Aviation and
Missile Command (AMCOM). */


